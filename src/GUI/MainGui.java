
package GUI;

import com.formdev.flatlaf.FlatDarkLaf;
import java.awt.MouseInfo;
import java.awt.Point;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;
import javax.swing.ButtonGroup;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author Michal
 */
public class MainGui extends javax.swing.JFrame {

StructuresContainer sct = new StructuresContainer(); //Klasa sluzaca do przechowywania wszystki informacji ktore zostana wprowadzone w trakcie dzialania programu
graphPanell paintSurface = new graphPanell(sct); //Panel na ktorym przeprowadzana jest wizualizacja i wszystkie pozostale operacje
ButtonGroup checkBoxesGroup = new ButtonGroup(); //Grupa przyciskow do tworzenia/dodawania nowych elementow geometrycznych - utworzona aby uniemozliwic na przyklad dodawanie linii w trakcie gdy wlaczone jest dodawnaie punktow
int clickCounter =0; //Licznik pomocniczy stworzony bo to by liczyc kliki w powierzchnie i na ich pdostawie wyznaczac poczatek i koniec lini/tworzyc linie
boolean startOk = false; //Przechowuje wynik sprawdzenia czy wybrany (jako poczatek liniI) punkt znajduje sie w zbiorze punktow narysowanych na powierzchni
boolean endOk = false; //Przechowuje wynik sprawdzenia czy wybrany (jako koniec linii) punkt znajduje sie w zbiorze punktow narysowanych na powierzchni
Point startEdgePoint; //Zmienna tymczasowa - przechowujaca chwilowy poczatek lini
Point endEdgePoint; //Zmienna tymczasowa - przechowujaca chwilowy koniec linii
Polygon selectedPolygon; //Zmienna 'tymczasowa' przechowujaca wszystkie informacje o wielokacie
int rowWithSelectedPolygon = -1;  //Zmienna pomocnicza - odpowiedzialna za pobranie wyboru z tabeli wielokatow. Na wybranym beda wykonywane pozniejsze wszystkie operacje
//int selectedSingleLine = -1; //Zmienna pomocnicza - odpowiedzialna za pobranie wyboru z tabeli lini pojedynczego rekordu (lini), na ktorej beda wykonywane pozniejsze operacje
int []selectedLines; //Zmienna pomocnicza - odpowiedzialna za pobranie wyboru linii z tabeli linii(linesTable) , na ktorych beda wykonywane dalsze operacje
int []selectedPoints; //Zmienna pomocnicza - odpowiedzialna za pobranie wyboru z tabeli punktow(pointsTable), na ktorych beda wykonywane dalsze operacje

    public MainGui() {
        initComponents();
        this.checkBoxesGroup.add(addingPointBox);
        this.checkBoxesGroup.add(addingEdgeBox);
        //createPointsTable();
        
        
            

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jSplitPane1 = new javax.swing.JSplitPane();
        operationsPanel = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        pointsTable = new javax.swing.JTable();
        polygonsLabel = new javax.swing.JLabel();
        avaliableLabel = new javax.swing.JLabel();
        addingPointBox = new javax.swing.JCheckBox();
        addingEdgeBox = new javax.swing.JCheckBox();
        crossingPointsButton = new javax.swing.JButton();
        convexHullButton = new javax.swing.JButton();
        randomPointsButton = new javax.swing.JButton();
        triangleAreaButton = new javax.swing.JButton();
        refreshButton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        linesTable = new javax.swing.JTable();
        jLabel2 = new javax.swing.JLabel();
        lineEquationButton = new javax.swing.JButton();
        clearAllButton = new javax.swing.JButton();
        kdTreeButton = new javax.swing.JButton();
        pointToLineButton = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();
        rPanel = new javax.swing.JPanel();
        graphPanel = paintSurface;
        wizualizacjaL = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setResizable(false);

        jSplitPane1.setDividerLocation(500);
        jSplitPane1.setDividerSize(0);

        operationsPanel.setPreferredSize(new java.awt.Dimension(500, 602));

        String[] cols = {"Nr punktu", "X", "Y"};
        DefaultTableModel pointsTableDefModel = new DefaultTableModel(cols,0){
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };
        pointsTable.setModel(pointsTableDefModel);
        jScrollPane1.setViewportView(pointsTable);
        if (pointsTable.getColumnModel().getColumnCount() > 0) {
            pointsTable.getColumnModel().getColumn(0).setResizable(false);
        }
        pointsTable.addMouseListener(new MouseAdapter(){
            public void mouseClicked(MouseEvent e){
                if (e.getClickCount() == 1){
                    JTable target = (JTable)e.getSource();
                    int[] selectedRows = target.getSelectedRows();
                    selectedPoints = selectedRows;
                }
            }
        });

        polygonsLabel.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        polygonsLabel.setText("Dane wielokata");

        avaliableLabel.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        avaliableLabel.setText("Dostępne operacje");

        addingPointBox.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        addingPointBox.setText("Włącz dodawanie punktow");

        addingEdgeBox.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        addingEdgeBox.setText("Włącz dodawanie lini");

        crossingPointsButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        crossingPointsButton.setText("<html><center>Wyznacz współrzędne<br />punktów przecięcia <br /> wybranych 2 linii</center></html>");
        crossingPointsButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                crossingPointsButtonActionPerformed(evt);
            }
        });

        convexHullButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        convexHullButton.setText("<html><center>Wyznacz <br />otoczkę wypukłą</center></html>");
        convexHullButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                convexHullButtonActionPerformed(evt);
            }
        });

        randomPointsButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        randomPointsButton.setText("<html><center>Wygeneruj losowe<br />punkty</center></html>");
        randomPointsButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                randomPointsButtonActionPerformed(evt);
            }
        });

        triangleAreaButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        triangleAreaButton.setText("<html><center>Oblicz pole trójkąta<br />złożonego z <br /> 3 wybranych punktow</center></html>");
        triangleAreaButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                triangleAreaButtonActionPerformed(evt);
            }
        });

        refreshButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        refreshButton.setText("Odśwież ekran");
        refreshButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                refreshButtonActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel1.setText("Linie");

        String[] cols2 = {"Nr linii", "Punkt początku", "Punkt końca"};
        DefaultTableModel linesTableDefModel = new DefaultTableModel(cols2,0){
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };
        linesTable.setModel(linesTableDefModel);
        jScrollPane2.setViewportView(linesTable);
        if (linesTable.getColumnModel().getColumnCount() > 0) {
            linesTable.getColumnModel().getColumn(0).setResizable(false);
        }
        linesTable.addMouseListener(new MouseAdapter(){
            public void mouseClicked(MouseEvent e){
                if (e.getClickCount() == 1){
                    JTable target = (JTable)e.getSource();
                    int[] selectedRows = target.getSelectedRows();
                    selectedLines = selectedRows;
                    // int row = target.getSelectedRow();
                    // selectedSingleLine = row;
                }
            }
        });

        jLabel2.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel2.setText("Punkty");

        lineEquationButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        lineEquationButton.setText("<html><center>Wyznacz równanie<br />wybranej linii</center></html>");
        lineEquationButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                lineEquationButtonActionPerformed(evt);
            }
        });

        clearAllButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        clearAllButton.setText("Wyczyść");
        clearAllButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                clearAllButtonActionPerformed(evt);
            }
        });

        kdTreeButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        kdTreeButton.setText("<html><center>Znajdz najblizszy<br />punkt do wybranego <br /> (Drzewa KD)</center></html>");
        kdTreeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                kdTreeButtonActionPerformed(evt);
            }
        });

        pointToLineButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        pointToLineButton.setText("<html><center>Wyznacz polozenie<br />wybranego punktu <br /> wzgledem wybranej linii</center></html>");
        pointToLineButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                pointToLineButtonActionPerformed(evt);
            }
        });

        jButton1.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jButton1.setText("<html><center>Wyznacz polozenie<br />wybranego punktu <br /> wzgledem wybranego wielokata</center></html>");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout operationsPanelLayout = new javax.swing.GroupLayout(operationsPanel);
        operationsPanel.setLayout(operationsPanelLayout);
        operationsPanelLayout.setHorizontalGroup(
            operationsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, operationsPanelLayout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(polygonsLabel)
                .addGap(132, 132, 132))
            .addGroup(operationsPanelLayout.createSequentialGroup()
                .addGap(124, 124, 124)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel2)
                .addGap(113, 113, 113))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, operationsPanelLayout.createSequentialGroup()
                .addGap(12, 12, 12)
                .addGroup(operationsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, operationsPanelLayout.createSequentialGroup()
                        .addGroup(operationsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(operationsPanelLayout.createSequentialGroup()
                                .addComponent(convexHullButton, javax.swing.GroupLayout.PREFERRED_SIZE, 144, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addGroup(operationsPanelLayout.createSequentialGroup()
                                .addGroup(operationsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, operationsPanelLayout.createSequentialGroup()
                                        .addGap(0, 0, Short.MAX_VALUE)
                                        .addComponent(crossingPointsButton, javax.swing.GroupLayout.PREFERRED_SIZE, 144, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(operationsPanelLayout.createSequentialGroup()
                                        .addComponent(randomPointsButton, javax.swing.GroupLayout.PREFERRED_SIZE, 144, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGap(0, 0, Short.MAX_VALUE)))
                                .addGap(18, 18, 18)))
                        .addGroup(operationsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(kdTreeButton)
                            .addComponent(lineEquationButton, javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(triangleAreaButton, javax.swing.GroupLayout.Alignment.LEADING))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(operationsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(refreshButton, javax.swing.GroupLayout.DEFAULT_SIZE, 155, Short.MAX_VALUE)
                            .addComponent(pointToLineButton, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                            .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                        .addGap(12, 12, 12))
                    .addGroup(operationsPanelLayout.createSequentialGroup()
                        .addGap(188, 188, 188)
                        .addComponent(avaliableLabel)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(operationsPanelLayout.createSequentialGroup()
                        .addGap(12, 12, 12)
                        .addGroup(operationsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(addingPointBox)
                            .addComponent(addingEdgeBox, javax.swing.GroupLayout.PREFERRED_SIZE, 233, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(clearAllButton, javax.swing.GroupLayout.PREFERRED_SIZE, 91, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(21, 21, 21)))
                .addGap(20, 20, 20))
            .addGroup(operationsPanelLayout.createSequentialGroup()
                .addGap(10, 10, 10)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 264, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                .addGap(32, 32, 32))
        );
        operationsPanelLayout.setVerticalGroup(
            operationsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(operationsPanelLayout.createSequentialGroup()
                .addGap(19, 19, 19)
                .addComponent(polygonsLabel)
                .addGap(10, 10, 10)
                .addGroup(operationsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jLabel2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(operationsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 148, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 148, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(operationsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(operationsPanelLayout.createSequentialGroup()
                        .addComponent(avaliableLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(operationsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(operationsPanelLayout.createSequentialGroup()
                                .addComponent(addingPointBox)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(addingEdgeBox))
                            .addGroup(operationsPanelLayout.createSequentialGroup()
                                .addGap(8, 8, 8)
                                .addComponent(clearAllButton, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(18, 18, Short.MAX_VALUE)
                        .addGroup(operationsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(lineEquationButton, javax.swing.GroupLayout.DEFAULT_SIZE, 61, Short.MAX_VALUE)
                            .addComponent(crossingPointsButton, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, operationsPanelLayout.createSequentialGroup()
                        .addGap(132, 132, 132)
                        .addComponent(refreshButton, javax.swing.GroupLayout.PREFERRED_SIZE, 61, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(18, 18, 18)
                .addGroup(operationsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, operationsPanelLayout.createSequentialGroup()
                        .addComponent(convexHullButton, javax.swing.GroupLayout.PREFERRED_SIZE, 61, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, operationsPanelLayout.createSequentialGroup()
                        .addGroup(operationsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(triangleAreaButton, javax.swing.GroupLayout.PREFERRED_SIZE, 61, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(pointToLineButton, javax.swing.GroupLayout.PREFERRED_SIZE, 61, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(11, 11, 11)))
                .addGroup(operationsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(randomPointsButton, javax.swing.GroupLayout.DEFAULT_SIZE, 61, Short.MAX_VALUE)
                    .addComponent(kdTreeButton, javax.swing.GroupLayout.DEFAULT_SIZE, 61, Short.MAX_VALUE)
                    .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                .addGap(39, 39, 39))
        );

        jSplitPane1.setLeftComponent(operationsPanel);

        rPanel.setForeground(new java.awt.Color(255, 255, 255));

        graphPanel.setBackground(new java.awt.Color(204, 204, 204));
        graphPanel.setBorder(javax.swing.BorderFactory.createCompoundBorder());
        graphPanel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                graphPanelMouseClicked(evt);
            }
            public void mousePressed(java.awt.event.MouseEvent evt) {
                graphPanelMousePressed(evt);
            }
        });

        javax.swing.GroupLayout graphPanelLayout = new javax.swing.GroupLayout(graphPanel);
        graphPanel.setLayout(graphPanelLayout);
        graphPanelLayout.setHorizontalGroup(
            graphPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 600, Short.MAX_VALUE)
        );
        graphPanelLayout.setVerticalGroup(
            graphPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 500, Short.MAX_VALUE)
        );

        wizualizacjaL.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        wizualizacjaL.setText("Wizualizacja");

        javax.swing.GroupLayout rPanelLayout = new javax.swing.GroupLayout(rPanel);
        rPanel.setLayout(rPanelLayout);
        rPanelLayout.setHorizontalGroup(
            rPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(rPanelLayout.createSequentialGroup()
                .addContainerGap(39, Short.MAX_VALUE)
                .addGroup(rPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, rPanelLayout.createSequentialGroup()
                        .addComponent(wizualizacjaL, javax.swing.GroupLayout.PREFERRED_SIZE, 175, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(218, 218, 218))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, rPanelLayout.createSequentialGroup()
                        .addComponent(graphPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(44, 44, 44))))
        );
        rPanelLayout.setVerticalGroup(
            rPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, rPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(wizualizacjaL, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(18, 18, 18)
                .addComponent(graphPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(47, 47, 47))
        );

        jSplitPane1.setRightComponent(rPanel);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSplitPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 1184, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSplitPane1)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void refreshButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_refreshButtonActionPerformed
    graphPanel.repaint();           
           
    }//GEN-LAST:event_refreshButtonActionPerformed

    private void randomPointsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_randomPointsButtonActionPerformed
        Point[] randomPoints = sct.algorithms.generateRandomPoints(10);
        for (int i=0; i< randomPoints.length; i++){
            sct.points.add(randomPoints[i]);
        }
        graphPanel.repaint();    
        resetPointsTable();
        //System.out.println("dodano");
    }//GEN-LAST:event_randomPointsButtonActionPerformed

    private void graphPanelMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_graphPanelMousePressed

        //Dodawanie punktow po kliknieciu w przestrzen odpowiedzialna za wizualizacje
        if (addingPointBox.isSelected()){
            Point p = MouseInfo.getPointerInfo().getLocation(); //Pobranie wspolrzednych punktu z obszaru panelu
            SwingUtilities.convertPointFromScreen(p, graphPanel); //Zrzutowanie na panel jesli ramka bylaby przesuwana,poniewaz zadne layouty nie sa wykorzystywane
            sct.points.add(p);
            graphPanel.repaint(); //Przerysowanie
            resetPointsTable(); //Odswiezenie tabli
            //System.out.println("Dodano punkt");
        }

        //Dodawanie lini po klienciu w punkt istniejacy w przestrzeni odpowiedzialnej za wizualizacje
        //Dodatkowo aby 'ulatwic' klikanie +/- 10px tolerancji w kazda ze stron
        if (addingEdgeBox.isSelected()){
            clickCounter++;
            if (clickCounter == 1){
                Point tmpStartPoint = evt.getPoint(); //Pobranie punktu startu po kliknieciu w przestrzen
                startEdgePoint = sct.isPointInSurface(tmpStartPoint); //Sprawdzenie czy dany punkt istnieje na liscie jesli tak to bedzie przypisany do aktualknego startEdgePointu
                //w przeciwnym razie bedzie nulem
            }

            if (clickCounter == 2){
                if (startEdgePoint !=null){  //Jesli punkt startowy zostal wybrany to
                    Point tmpEndPoint = evt.getPoint(); //Pobranie punktu konca po kliknieciu drugi raz w przestrzen
                    endEdgePoint = sct.isPointInSurface(tmpEndPoint); //Sprawdzenie czy dany punkt istnieje na liscie. jesli tak to bedzie przypisany do aktualnego endEdgePointa
                    if (endEdgePoint !=null && endEdgePoint != startEdgePoint){ //Jak jest koniec to poczatek rowniez musi byc wiec mozna utworzyc krawedz i koniec nie moze byc taki sam jak poczatek
                        Edge edgeTmp = new Edge(startEdgePoint, endEdgePoint);
                        sct.edges.add(edgeTmp);
                        //System.out.println("Linia dodana");
                        graphPanel.repaint(); //refresh
                        clickCounter = 0; //reset parametrow
                        startEdgePoint = null;
                        endEdgePoint = null;
                        resetLinesTable();
                    }
                    else{
                        startEdgePoint = null;
                        clickCounter = 0;
                    }

                }

            }
            if (clickCounter >= 3){ //Jesli sie nie udalo za pierwszym razem stworzyc krawedzi to reset parameterow
                clickCounter = 0;
                startEdgePoint = null;
                endEdgePoint = null;
            }
        }
    }//GEN-LAST:event_graphPanelMousePressed

    private void graphPanelMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_graphPanelMouseClicked

    }//GEN-LAST:event_graphPanelMouseClicked

    private void convexHullButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_convexHullButtonActionPerformed
          System.out.println(sct.convexHullEnabled);
        sct.setConvexHullEnabled();
        graphPanel.repaint(); //Czyzczenie ekranu
        sct.convexHullResult = sct.algorithms.convexHull(sct.points); //Wyznaczanie otoczki wypuklej na zbiorze punktow
    }//GEN-LAST:event_convexHullButtonActionPerformed

    private void lineEquationButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_lineEquationButtonActionPerformed
      
        //Wyznaczanie rownania linii na podstawie wybranej z tabeli sposrod juz istniejacych a nastepnie wypisanie rownania w optionPane
        //Jesli nie wybrano zadnej lini to nie da sie obliczyc jej rownania
        if (selectedLines.length == 0)
            JOptionPane.showMessageDialog(null, "Nie wybrano jeszcze żadnej linii !", "Błąd", JOptionPane.INFORMATION_MESSAGE);
        else if (selectedLines.length == 1){
            //Jesli wybrano istniejaca linie z tabeli to mozna obliczyc jej rownanie
            //Tworzona jest linia tymczasowa, do ktorej przypisywana jest linia pobrana z listy na podstawie numeru w tabeli (zawsze jest ten sam co w oryginalnej liscie)
            //Mozna by skrocic kod, ale tak jest bardziej czytelnie chociaz mniej optymalnie (nie potrzebna dodatkowa zmienna eTMP)
            Edge eTmp = sct.edges.get(linesTable.convertRowIndexToModel(selectedLines[0]));
            String lineEquation = sct.algorithms.lineEquation(eTmp);
            JOptionPane.showMessageDialog(null, "Rownanie prostej: "+lineEquation, "Rownanie linii", JOptionPane.INFORMATION_MESSAGE);
        }
        else
            JOptionPane.showMessageDialog(null, "Wybrano wiecej niz jedna linie !", "Błąd", JOptionPane.INFORMATION_MESSAGE);
    }//GEN-LAST:event_lineEquationButtonActionPerformed

    private void crossingPointsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_crossingPointsButtonActionPerformed
        //Wyznaczanie punktu przeciecia dwoch lini na podstawie dwoch lini wybranych z tabeli sposrod juz istniejacych a nastepnie wypisanie punktu w optionPane
        if (selectedLines.length == 2){
            //Jesli wybrano dwie istniejace linie z tabeli to mozna obliczyc ich punkt przeciecia
            Edge e1Tmp = sct.edges.get(linesTable.convertRowIndexToModel(selectedLines[0]));
            Edge e2Tmp = sct.edges.get(linesTable.convertRowIndexToModel(selectedLines[1]));
            Point resultPoint = sct.algorithms.crossingPointCramerMod(e1Tmp, e2Tmp); //Obliczenia
            JOptionPane.showMessageDialog(null, "Punkt przeciecia wybranych lini to:\n("+resultPoint.x+","+resultPoint.y+")", "Punkt przeciecia", JOptionPane.INFORMATION_MESSAGE);           
        }
        else 
            JOptionPane.showMessageDialog(null, "Wybrano niepoprawną ilosc linii !", "Błąd", JOptionPane.INFORMATION_MESSAGE); 
    }//GEN-LAST:event_crossingPointsButtonActionPerformed

    private void clearAllButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearAllButtonActionPerformed
        //Czyszczenie wszystkich wprowadzonych danych
        sct.edges.clear();
        sct.points.clear();
        resetPointsTable();
        resetLinesTable();
        graphPanel.repaint();
    }//GEN-LAST:event_clearAllButtonActionPerformed

    private void triangleAreaButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_triangleAreaButtonActionPerformed
       
        //Obliczanie pola trojkata zlozonego z trzech podanych punktow,bedacych wierzcholkami, na podstawie 3 punktow wybranych z tabeli sposrod juz istniejacych
        //Wraz ze sprawdzeniem czy z wybranych punktow da sie zbudowac trojkat i wypisanie wyniku obliczen w optionPane
        if (selectedPoints.length == 3){
            Point p1 = sct.points.get(pointsTable.convertRowIndexToModel(selectedPoints[0]));
            Point p2 = sct.points.get(pointsTable.convertRowIndexToModel(selectedPoints[1]));
            Point p3 = sct.points.get(pointsTable.convertRowIndexToModel(selectedPoints[2]));
            
            if(sct.algorithms.isTrianglePossible(p1, p2, p3)){
                double calculatedArea = sct.algorithms.areaOfTriangle(p1, p2, p3);
                JOptionPane.showMessageDialog(null, "Pole wybranego trojkata wynosi:\n"+calculatedArea, "Pole trojkata", JOptionPane.INFORMATION_MESSAGE); 
            }
            else
                JOptionPane.showMessageDialog(null, "Z podanych wierzcholkow nie mozna zbudowac trojkata", "Błąd", JOptionPane.INFORMATION_MESSAGE);               
        }
        else
            JOptionPane.showMessageDialog(null, "Wybrano niepoprawną ilość punktów !", "Błąd", JOptionPane.INFORMATION_MESSAGE); 
    }//GEN-LAST:event_triangleAreaButtonActionPerformed

    private void kdTreeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_kdTreeButtonActionPerformed
       //Budowanie drzewa KD i wyszukiwanie w nim najblizszego sasiada do wybranego punktu
        if (selectedPoints.length == 1){
            Point p1 = sct.points.get(pointsTable.convertRowIndexToModel(selectedPoints[0]));
            sct.enableAndBuildKdTREE(p1);          
            double [] foundedPoint;
            foundedPoint = sct.findClosestPointInKdTree(p1);          
            System.out.println(foundedPoint[0]+ " "+ foundedPoint[1]);          
            System.out.println(sct.closestPoints.get(1));           
            graphPanel.repaint();
           // sct.isKdTreeEnabled = false;
        }
        else
           JOptionPane.showMessageDialog(null, "Wybrano niepoprawną ilość punktów !", "Błąd", JOptionPane.INFORMATION_MESSAGE); 
    }//GEN-LAST:event_kdTreeButtonActionPerformed

    private void pointToLineButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_pointToLineButtonActionPerformed
        //Sprawdzenie po ktorej stronie wybranej linii znajduje sie wybrany punkt
        //Metoda uruchomi sie tylko gdy z tabeli wybrana jest jedna linia i jeden punkt
        if (selectedPoints.length == 1 && selectedLines.length == 1){
            Point p1 = sct.points.get(pointsTable.convertRowIndexToModel(selectedPoints[0]));
            Edge e1 = sct.edges.get(linesTable.convertRowIndexToModel(selectedLines[0]));
            String result = sct.algorithms.whichSide(e1, p1);
            JOptionPane.showMessageDialog(null, result , "Polozenie punktu wzgledem linii", JOptionPane.INFORMATION_MESSAGE); 
        }
        else
            JOptionPane.showMessageDialog(null, "Wybrano niepoprawna ilosc danych" , "Błąd", JOptionPane.INFORMATION_MESSAGE);
    }//GEN-LAST:event_pointToLineButtonActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
       // Sprawdzenie gdzie znajduje sie podany przez uzytkownika punkt, wzgledem punktow wybranych z tabeli
       //Metoda uruchomi sie tylko gdy z tabeli wybranych jest co najmniej 3 punkty
       if (selectedPoints.length >= 3){
           //Utworzenie customowego optionPane, ktory pozwoli pobrac od uzytkownika wspolrzedne punktu, dla ktorego maja byc przeprowadzone obliczenia
          JTextField xCord = new JTextField();
          JTextField yCord = new JTextField();
          final JComponent[] inputs = new JComponent[] {
               new JLabel("Współrzędna X:"),
                         xCord,
               new JLabel("Współrzędna Y:"),
                         yCord,
           };
           int result = JOptionPane.showConfirmDialog(null, inputs, "Wprowadz współrzędne punktu", JOptionPane.PLAIN_MESSAGE);
        if (result == JOptionPane.OK_OPTION) {
            //Jesli wszystko porzebieglo pomyslnie, wspolrzedne zostaly pobrane to program przystepuje do wykonania algorytmu
       Point [] points = new Point [selectedPoints.length];
       //Pobranie wybranych punktow z tabeli
       for (int i=0; i<selectedPoints.length; i++){
           points[i]  = sct.points.get(pointsTable.convertRowIndexToModel(selectedPoints[i]));
       }
       Point userPoint = new Point();
       userPoint.x = Integer.parseInt(xCord.getText());
       userPoint.y = Integer.parseInt(yCord.getText());
       String resultCalculations = sct.algorithms.isInside(points, userPoint);
       JOptionPane.showMessageDialog(null, resultCalculations , "Polozenie punktu wzgledem wielokata", JOptionPane.INFORMATION_MESSAGE); 
       }
       }      
       else
           JOptionPane.showMessageDialog(null, "Wybrano niepoprawna ilosc danych" , "Błąd", JOptionPane.INFORMATION_MESSAGE);  
        
    }//GEN-LAST:event_jButton1ActionPerformed

    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MainGui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MainGui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MainGui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainGui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
                try{
            UIManager.setLookAndFeel(new FlatDarkLaf());
        } catch (Exception ex){
            System.out.println("Error");
        }
                
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new MainGui().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBox addingEdgeBox;
    private javax.swing.JCheckBox addingPointBox;
    private javax.swing.JLabel avaliableLabel;
    private javax.swing.JButton clearAllButton;
    private javax.swing.JButton convexHullButton;
    private javax.swing.JButton crossingPointsButton;
    private javax.swing.JPanel graphPanel;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JButton kdTreeButton;
    private javax.swing.JButton lineEquationButton;
    public static javax.swing.JTable linesTable;
    private javax.swing.JPanel operationsPanel;
    private javax.swing.JButton pointToLineButton;
    public javax.swing.JTable pointsTable;
    private javax.swing.JLabel polygonsLabel;
    javax.swing.JPanel rPanel;
    private javax.swing.JButton randomPointsButton;
    private javax.swing.JButton refreshButton;
    private javax.swing.JButton triangleAreaButton;
    private javax.swing.JLabel wizualizacjaL;
    // End of variables declaration//GEN-END:variables

    //Metoda pomocnicza odpowiedzialna za tworzenie widoku wielokatow w tabeli
    void createPointsTable(){
//        String[] cols = {"Nr punktu", "X", "Y"};
//        DefaultTableModel pointsTableDefModel = new DefaultTableModel(cols,0){
//            @Override
//            public boolean isCellEditable(int row, int column) {
//                return false;
//            }
//        };
//        pointsTable.setModel(pointsTableDefModel);
//        
//        for (int i=0; i<sct.polygons.size(); i++){
//            int pointNumber = i;
//            int xCord = sct.points.get(i).x;
//            int yCord = sct.points.get(i).y;
//            System.out.println(xCord);
//            
//            Object[] data = {pointNumber,xCord,yCord};
//            pointsTableDefModel.addRow(data);     
//            System.out.println("Dodano");
//        }       
    }
    
    //Metoda odpowiedzialna za dokonywanie odswiezenia tabeli w przypadku wykonania jakiejkolwiek zmiany w tabeli typu dodanie punktu albo linii
    void resetPointsTable(){
        DefaultTableModel model = (DefaultTableModel) pointsTable.getModel();
        model.setRowCount(0);
      for (int i=0; i<sct.points.size(); i++){
        int pointNumber = i;
        int xCord = sct.points.get(i).x;
        int yCord = sct.points.get(i).y;
       // System.out.println(xCord);

        Object[] data = {pointNumber,xCord,yCord};
        model.addRow(data);
        }//reset
    }
    
        void resetLinesTable(){
        DefaultTableModel model = (DefaultTableModel) linesTable.getModel();
        model.setRowCount(0);
      for (int i=0; i<sct.edges.size(); i++){
        int lineNumber = i;
        String pStartTmp = sct.edges.get(i).vertices[0].toString();
        Point pEndTmp = sct.edges.get(i).vertices[1];

        Object[] data = {lineNumber,pStartTmp,pEndTmp};
        model.addRow(data);
        //System.out.println("Dodano");
        }//reset
    }

    


}
